ctrl-C
    Interrupts the process.Many processes (including any program you write 
    unless you trap SIGINT using the sigaction system call) Will die 
    instantly when you do this, Some won't.

ctrl-Z
    Suspend the process.This will leave a stopped process lying around.Type
    jobs to list all your stopped processes, fg to restart the last process
    (or fg %1 to start process %1 etc.), bg to keep running the stopped
    process in the background, kill %1 politely, kill -KILL %1 whether it 
    wants to die or not.
ctrl-D
    Send end-of-file to the process. Useful if you are typing test input to
    a process that expects to get EOF eventually or writing programs using
    cat > program.c (not really recommended).For test input, you are often
    better putting it into a file and using the input redirection
    ( ./program < test-input-file); this way you can redo the test after
    you fix the bugs it reveals.
ctrl-\
    Quit the process.Sends a SIGQUIT , which asks a process to quit and dump
    core. Mostly useful if ctrl-C and ctrl-Z don't work.

If you have runaway process that you can't get rid of otherwise, you can use
ps to get a list of all your processes and their process ids. The kill command
can then be used on the offending process, e.g. kill -KILL 6666 if your
evil process has process id 6666. Sometimes the killall command can simplify
this procedure, e.g. killall -KILL evil kills all process with command name
evil.

Redirection input and output
    Some programs take input from standard input (typically the terminal).If
    you are doing a lot of testing , you will quickly become tired of typing
    test input at your program.You can tell the shell to redirect standard
    input from a file by putting the file name after a < symbol, like this:

    $ ./cout <huge-input-file
    
    A '>' symbol is used to redirect standard output, in case you don't 
    want to read it as flies by on your screen:

    $ ./count <huge-input-file > huger-output-file

    A useful file for both input and output is the special file /dev/null.
    As input, it looks like an empty file.As output, it eats any character
    send to it:

    $ ./sensory-deprivation-experiment < /dev/null > /dev/null

    You can also pipe programs together , connecting the output of one to
    the input of the next.Good programs to put at the end of a pipe are
    head (eats all but the first ten lines), tail (eats all but the last
    ten lines), more(lets you page through output by hitting the space bar,
    and tee (shows you the output but also saves a copy to a file).
    A typical command might be something like ./spew | more    or
    ./slow-but-boring | tee-boring-output
    Pipes can consist of a long train of programs, each of which processes
    the output of the previous one and supplies the input to the next. A
    typical case might be:
    
    $ ./do-many-experiments | sort | uniq -c | sort -nr
    
    which , if ./do-many-experiments gives the output of one experiment on 
    each line, produces a list of distinct experimental outputs sorted by
    decreasing frequency. Pipes like this can often substitute for hours
    of real programming.

Watching your program run
    1.Compile your program with the -g3 flag.You can still run gdb if you don't
      do this, but it won't be able to show you variable names or source lines.
    2.Run gdb with gdb programname.
    3.Type break main to stop at the start of the main routine.
    4.Run your program with run arguments. The run command stands in for the 
      program name.You can also redirect input as in the shell with run
      run arguments < filename.
    5.When the program stops, you can display variables in the current function
      of expressions involving these variables using display, as in display x, 
      display a[i], display z+17. In ddd, double clicking  on variable name 
      will have the same effect.Use undisplay to get rid of any displays you
      don't want.
    6.To step through your program , use next(always goes to next line in the 
      current function, not dropping down into function calls), step (go to 
      the next executed line, even if it is inside a called function),
      finish (run until the current function returns), and cont(until the  end
      of the program or the next breakpoint).

profiling
    compile program with -pg option to gcc, which inserts profiling code that
    counts how many times each function is called and how long(on average) each
    call takes.

    Because the profile is not very smart about shared libraries , we also 
    include the --static option to force the resulting program to be statically
    linked. This means that all the code that is used by the program is baked 
    into the executable instead of being linked in at run-time.(Normally we
    don't do this because it makes far big executables and big running 
    programs, since statically-linked libraries can't be shared between more
    than one running program.)

Output of preprocessor 
    You can see what the output of the preprocessor looks like by calling 
    the C compiler with the -E option, as in c99 -E sumRanges.c

Journey of C source code to executable:
    sumRange.c (source code)
        |
        v
    [preprocessor (cpp)]
        |
        v
    preprocessed version of sumRange.c
        |
        v
    [compiler (gcc)]
        |
        v
    sumRanges.s (assembly code)
        |
        v
    [assembler (as)]
        |
        v
    sumRange.o (machine code)
        |
        v
    [linker (ld)] <- system library (glibc.a)
        |
        v
    sumRange (executable)
The good news is, you don't actually have to run all of these steps
yourself; instead, gcc(which you may be calling as c99) will take care of
everything for you, particularly for simple programs like sumRange.c that
fit in a single file.

EOF getchar()
    There is slight gotcha for character processing with input function like
    getchar and getc. These return the special value EOF(defined in stdio.h
    to be -1) to indicate end of file. But 255, which represents 'y'(two 
    dots above) in the ISO Latin-1 alphabet and in Unicode and which may
    also appear quite often in binary files, will map to -1 if you put it in
    a character. So you should store the output of these functions in an int
    if you need to test for end of file. Once you have done this test, it's
    OK to put the non-end-of-file character back in a char.
    
    /*right*/
    int c;

    while((c = getchar()) != EOF){
        putchar(c);
    }

    /*wrong*/
    char c;

    while((c = getchar()) != EOF) { /* <- DON'T USE THIS! */
        putchar(c);
    }
    
mod for floating point (modf)
    Some operators that work on integers will not work on floating-point
    types. These are % (use modf from the math library if you really need to
    get a floating-point remainder) and all of the bitwise operators:
    ~ , >> , << , & ,^ , and |

floor, ceil, round, trunc, and nearbyint in the GNU libc reference manual

The IEEE-754 floating-point standard
    The IEEE-754 floating-point standard is a standard for representing and
    manipulating floating-point quantities that is followed by all modern
    computer systems.It defines several standard representation of floating
    point numbers, all of which have the following basic pattern (the 
    specific layout here is for 32-bit floats):

    bit    31 30    23 22                    0
           S  EEEEEEEE MMMMMMMMMMMMMMMMMMMMMMM

    S- sign bit ( + ve or -ve) 0 -> positive , 1 -> negative
    EEEEEEEE - exponents in excess-127 binary notation;
    ''' to long to read please go through it later :) '''

error
    Error In general, floating-point numbers are not exact: they are likely
    to contain round-off error because of the truncation of the mantissa to
    a fixed number of bits. This is particularly noticeable for large values
    (e.g. 1e+12 in the table above), but can also be seen in fractions with
    values that aren't powers of 2 in the denominator (e.g. 0.1). Round-off
    error is often invisible with the default float output formats, since
    they produce fewer digits than are stored internally, but can accumulate
    over time, particularly if you subtract floating-point quantities with
    values that are close(this wipes out the mantissa without wiping out the
    error, making the error much larger relative to the number that remains)

    Note that a consequence of the internal structure of IEEE 754 floating-
    point numbers is that small integers and fractions with a small 
    numerators and power-of-2 denominators can be represented exactly-indeed
    , the IEEE 754 standard carefully defines floating-point operations so
    that arithmetic on such exact integers will give the same answer as 
    integer arithmetic would(except of course, for division that produces
    a remainder). This fact can sometimes be exploited to get higher
    precision on integer values than is available from the standard integer
    types; 
    For example, a double can represent any integer between -2^53 to 2^53 
    exactly, which is a much wider range than the values from -2^31 to 
    2^31-1 that fit in a 32-bit int or long. (A 64-bit long long does better
    ) so double should be considered for applications where large precise
    integers are needed (such as calculating the net worth in pennies of
    a billionare.)

math.h linking is not done by default
    gcc -o program program.c -lm
    If you don't do this , you will get errors from the compiler about 
    missing functions. The reason is that the math library is not linked in
    by default, since for many system programs it's not needed.

Unary operators, ternary ?: and assignment operators are the only ones that
associate right-to-left
For unary operators, this mostly affects expressions like *p++, which is 
equivalent to *(p++) (increment the pointer first then dereference it) 
rather than (*p)++ (increment the thing that p points to).

variable
    A variable is a name given in a program for some region of memory. Each
    variable has a type, which tells the computer how big the region of 
    memory corresponding to it and how to treat the bits stored in that 
    region when performing various kinds of operations(e.g. integer 
    variables are added together by very different circuitry than floating-
    point variables , even though both represent numbers as bits). In 
    modern programming languages, a variable also has a scope ( a limit on
    where the name is meaningful, which allows the same name to be used for
    different variables in different variables in different parts of the
    program) and an extent (the duration of the variable's existence, 
    controlling when the program allocates and deallocates space for it).

_variablename
    An identifier in C must start with a lower or uppercase letter or the
    underscore character _. Typically variables starting with underscores 
    are used internally by system libraries, so it's dangerous to name your
    own variables this way.

static and global initializer case
    For ordinary local variables, the initializer value can be any
    expression, including expression that call other functions. There is an
    exception for variables allocated when the program starts (which 
    includes global variables outside functions and static variables inside
    functions), which can only be initialized to constant expressions.

    const char * const greeting = "Hello Anupam!";
    const int greetingLength = strlen(greeting);

    The last two examples show how initializers can set the value of
    variables that are declared to be const (the variable greeting is both
    constant itself, because of const greeting, because it is of type
    const char). This is the only way way to set the values of such
    variables without cheating, because the compiler will complain if you
    try to do an ordinary assignment to a variable declared to be constant.

static variables - when you want to use it?
    a) you only need one instance of , 
    b) you need to survive between function calls, and
    c) it would be annoying to pass around as an extra argument to any function
       that uses it.
    An example would be the internal data structures used by malloc, or the 
    count variable.

Additional qualifiers for global variables
    Here are three variable declarations that illustrates how this work
    unsigned short Gloabl = 5; /* global variable, can be used anywhere */
    extern float GlobalFloat; /* this global variable, defined somewhere else,
    	   	 	      	 has type */
    static char Character = 'c'; /* global variable, can only be used by
    	   		    	    functions in this file only */
    Typically, an extern definition would appear in a header file so that it 
    can be included in any function that uses the variable, while an oridinary
    global variable definition would appear in a C file so it only occurs once.

Pointers to const
    A pointer to a region that should not be modified should be declared with
    const type:
        const char *string = "You cannot modify this string.";
    The const in the declaration above applies to the characters that string
    points to: string is not const itself, but is instead a pointer to const.
    It is still possible to make string point somewhere else, say by doing an
    assignment:
	string = "You cannot modify this string either."
    If you want to make it so that you can't assign to string, put const right
    before the variable name:
        /* prevent assigning to string as well */
    const char * const string = "You cannot modify this string.";

getchar() and putchar()
    Both getchar() and putchar() are wrappers for more general routines getc
    and putc that allows you to specify which stream you are using. To 
    illustrate getc and putc, here's how we might define getchar and putchar if
    they didn't exist already:
    	 int getchar2(void)
	 { 
	   return getc(stdin):
	 }
	 
	 int putchar2(void)
	 {
	   return putc(c, stdout);
	 }
ungetc
    A rather odd feature of the C standard I/O library is that if you don't 
    like the character you just got, you can put it back using the ungetc 
    function. the limitation on ungetc are that (a) you can only push one 
    character back, and (b) that character can't be EOF. The ungetc function
    is provided because it makes certain high level input tasks easier; for 
    example, if you want to parse a number written as a sequence of digits, you
    need to be able to read characters until you hit the first non-digit.But if
    the non-digit is going to be used elsewhere in your program, you don't want
    to eat it. The solution is to put it back using ungetc.

recursive descent parser
    because calc.c routines calls itself recursively as it works its way 
    down through the input, it is an example of a recursive descent parser.
    Parsers for more complicated languages like C is usually not written by
    hands like this, but are instead constructed mechanically using a
    Parser generator.
File I/O
    Reading and writhing files is done by creating new streams attached to
    the files. The function that does this is fopen. It takes two arguments:
    a filename, and a flag that controls whether the file is opened for 
    reading or writing. The return value of fopen has type FILE* and can be
    used in putc, getc, fprintf, etc. just like stdin, stdout, or stderr.
    When you are done using a stream, you should close it using fclose.

Function declarations and modules
    By default, functions have global scope: they can be used anywhere in your 
    program , even in other files. If a file doesn't contain a declaration for
    a function someFunc before it is used, the compiler will assume that it is
    declared like int someFunc() (i.e. return type int and unknown arguments).
    This can produce infuriating complaints later when the compiler hits the real
    declaration and insists that your function someFunc should be returning an 
    int and your are a bonehead for declaring it otherwise.

    The solution to such insulting compiler behaviour errors is tho either a) 
    move the function declaration before any functions that use it; or b) put it
    in a declarattion without a body before any functions that use it, in 
    addition to the declaration that appears in the function definition.( Note 
    that this violates the no seperate but equal rule, but the compiler should 
    tell you when you make a mistake.) Option b) is generally preffered, and is
    the only option when the function is used in a different file.
    
    To make sure all declartions of a function are consistent , the usual 
    practice is to put them in an include file. For example, if distSquared in 
    used in a lot of place, we might put it in its own file distSquared.c:
    
	#include "distSquared.h"
	
	int distSqared(int dx, int dy)
	{ 
	  return dx*dx + dy*dy;
	}

    save it as a examples/functions/distSquared.c
    The file distSquared.c above uses #include to include a copy of the following
    header file distSquared.h:

        /* Returns the square of the distance between two points separated by 
	   dx in the x direction and dy in the y direction. */
	int distSquared(int dx, int dy);
  
    save it as a examples/functions/distSquared.h

Static functions
    By default, all functions are global; they can be used in any file of your 
    program whether or not a declaration appears in a header file. To restrict
    access to the current file, declare a function static.
    It's generally good practice to declare a function static unless you intend 
    to make it unavailable, since not doing so can cause namespace conflicts, 
    where the presence of two functions with the same name either prevents the
    program from linking or -even worse -- cause the wrong function to be 
    called.The latter can happen with library functions, since C allows the 
    programmer to override library functions by defining a new function with
    the same name.(but C++ does not , remember once you tried to create a 
    swap function , but it turns out that there was already a swap function 
    in std::swap).

Static variables
    Static local variables are stored outside the stack with global variables,
    and have unbounded extent. But they are only visible inside the function
    that declares them. This makes them slightly less dangerous than global
    variables -- there is no fear that some foolish bit of code elsewhere 
    will quietly change their value -- but it is still the case that they 
    usually aren't what you want. It is also likely that operations on 
    static variables will be slightly slower than operations on ordinary
    ("automatic") variables , since making them persistent means that they 
    have to be stored in (slow) main memory insted of (fast) registers.

Pointer Preference
    (*p)++;         /* increment the value pointed to by p */
    *p++;           /* WARNING: increments p itself */
    You can print a pointer value using printf with the %p format specifier.
    To do so, you should (note that should not must) convert the pointer to
    type void * first using a cast ( see below for void * pointers), although
    on machines that don't have different representations for different pointer
    types, this may not be necessary.

Null Pointer
    The special value 0, known as the null pointer, may be assigned to a
    pointer of any type.It may or may not be represented by the actual
    address 0, but it will act like 0 in all contexts (e.g., it has the 
    value false in an if or while statement). Null pointers are often used
    to indicate missing data or failed functions. Attempting to dereference
    a null pointer can have catastrophic effects, so it's important to be
    aware of when you might be supplied with one.

pointers as function arguments
    Generally if you pass the value of a variable into a function(with no &)
    , you can be assured that the function can't modify your original 
    variable. When you pass a pointer, you should assume that the function
    can and will change the variable's value. If you want to write a 
    function that takes a pointer argument but promises not to modify the
    target of the pointer, use const, like this:
    	   void printPointerTarget(const int *p) {
	   	printf("%d\n", *p);
	   }
    The const qualifier tells the compiler that the target of the pointer 
    shouldn't be modified. This will cause it to return an error if you try
    to assign to it anyway:
           void printPointerTarget(const int *p) {
	   	*p = 5; / * produces compile-time error */
		printf("%d\n", *p);
	   }
    Passing const pointers is mostly used when passing large structures to 
    functions, where copying a 32-bit pointer is cheaper that copying the
    thing it points to.

cast away const:
    If you really want to modify the target anyway, C lets you "cast away
    const":
	void printPointerTarget(const int *p) {
	     *((int *) p) = 5; /* no compile time error */
	     printf("%d\n", *p);
	}
    There is no good reason to do this. The one exception might be if the
    target of the pointer represents an abstract data type, and you want to
    modify its representation during some operation to optimize things 
    somehow in a way that will not be visible outside the abstraction
    barrier, making it appear to leave the target constant.

pointers should not be returned from a function
    Note that while it is safe to pass pointers down into functions, it is
    very dangerous to pass pointers up. The reason is that the space used to
    hold any local variable of the function will be reclaimed when the 
    function exists, but the pointer will still point to the same location.
    even though something else may now be stored there. So this is very
    dangerous:
	int * dangerous(void) {
	    int n;
	    return &n;       /* NO! */
	}
	...
	*dangerous() = 12; /* writes 12 to some unknown location */    
    An exception is when you can guarantee that the location pointed to will
    survive even after the function exits, e.g. when the location is 
    dynamically allocated using malloc (see below) or when the local 
    variable is declared static:
    	     int *returnStatic(void) {
	     	 static int n;
		 return &n;
	     }
	     ...
	     *returnStatic() = 12; /* writes 12 to the hidden static variable */

Pointer arithmetic and arrays
    Because pointers are just numberical values , one can do arithmetic on 
    them. Specifically, it is permitted to
    * Add an integer to a pointer or subtract an integer from a pointer. The
      effect of p+n where p is a pointer and n is an integer is to compute
      the address equal to p plus n times the size of whatever p points to 
      (this is why int * pointers and char * pointers aren't the same).
    * Subtract one point from another. The two pointers must have the same
      type (e.g. both int * or both char *). The result is a signed integer
      value of type ptrdiff_t, equal to the numberical difference between
      the addresses divided by the size of the objects pointed to.
    * Compare two pointers using ==, !=, <, >, <= , or >=.
    * Increment or decrement a pointer using ++ or --.

Array 
    The array name acts like a constant pointer to the zeroth element of the
    array. It is thus possible to set or read the zeroth element using *a.
    But because the array name is constant, you can't assign to it:
    	*a = 12;            /* sets zeroth element to 12 */
	 a = &n;            /* #### DOESN'T WORK #### */

accessing array element beyond range
    Note that C doesn't do any sort of bounds checking. Given the 
    declaration int a[50]; , only indices from a[0] to a[49] can be used
    safely. However, the compiler will not blink at a[-12] or a[10000]. If 
    you read from such a location you will get garbage data; if you write to
    it, you will overwrite god-knows-what, possibly trashing some other 
    variable somewhere else in your program or some critical part of the
    stack (like the location to jump to when you return from a function).
    
buffer overruns:
    It is upto you as a programmer to avoid such buffer overruns, which can
    lead to very mysterious ( and in the case of code that gets input from
    a network, security-damaging) bugs. The valgrid program can help detect
    such overruns in some cases.

(int *a) or (int a[])
    In a function argument int a[] is just syntactic sugar for int *a. You 
    can even modify what a points to inside sumArray by assigning to it. 
    This will allow to do things that you usually don't want to do, like 
    this hideous routine:
    	 /* return the sum of the first n values in a */
	 int sumArray(int n, const int a[]) {
	     const int *an;  /* pointer to first element not in a */
	     int sum;
	     sum = 0;
	     an = a + n;
	     while( a < an) {
	     	    sum += *a++;
             }
	     return sum;
	 }

2D array:
   Like other array declarations, the size must be specified at compile 
   in pre-C99 C. If this is not desirable, a similar effect can be obtained
   by allocating each row seperately using malloc and building a master list
   of pointers to rows, of type int **. The downside of this approach is
   that the array is no longer contiguous ( which may affect cache
   performance) and it requires reading a pointer to find the location of a
   particular value, instead of just doing address arithmetic starting from
   the base address of the array. But elements can still be accessed using 
   the a[i][j] syntax. 

Variable-length arrays:
    C99 adds the feature of variable-length arrays, where the size of the 
    array is determined at run-time. These can only appear as local variables
    in procedures (automatic variables) or in argument lists. In the case of
    variable-length arrays in argument lists, it is also necessary that the
    length of the array be computable form previous arguments.

    Variable-length Arrays can Sometimes be used for run-time storage 
    allocation , as an alternative to malloc and free . A variable-length
    Array allocated as a local variable will be deallocated when the 
    containing scope (usually a function body, but maybe just a compound
    statement marked off by braces) exits. One consequence of this is 
    that you can't return a Variable-length array from a function.

    While using Variable-length arrays for this purpose can simplify code in
    some cases, as a general programming practice it is extremely dangerous.
    The reason is  that, unlike allocations through malloc, Variable-length
    array allocations are typically allocated on the stack (which is often
    more constrained than the heap) and have no way of reporting failure.
    So if there isn't enough room for your variable-length array, odds are
    you won't find out until a segmentation fault occurs somewhere later in
    your code when you try to use it.
    (As an additional annoyance, gdb is confused by two-dimensional variable
    -length arrays.)

Void Pointers
    A special pointer type is void *, a "pointer to void". Such pointers are
    declared in the usual way:
    	     void *nothing;   /* pointer to nothing */
    Unlike ordinary pointers, you can't dereference a void * pointer or do
    arithmetic on it, because the compiler doesn't know what type it points
    to. However, you are allowed to use a void * as a kind of "raw address"
    pointer value that you can store arbitrary pointers in. It is permitted
    to assign to a void * variable from an expression of any pointer type; 
    conversely, a void * pointer value can be assigned to a pointer variable
    of any type. An example is the return value of malloc or the argument
    of a free, both of which are declared as void.
    * Note that K&R suggests using an explicit cast for the return value of
      malloc. This is now acknowledged by the authors to be an error, which
      arose from the need for a cast prior to the standardization of void * in 
      ANSI C. See http://cm.bell-labs.com/cm/cs/cbook/2ediffs.html
      	   
	   int *block;

	   block = malloc(sizeof(int) * 12); /* void * converted to int * before assignment */
	   free(block);                      /* int * converted to void * before passing to free */

    If you need to use a void * pointer as a pointer of a particular type in an
    expression, you can cast it to the appropriate types by prefixing it with
    a type name in parentheses, like this:
        int a[50];      /* typical array of ints */
        void *p;        /* dangerous void pointer */
        
        a[12] = 17;     /* save that valuable 17 */
        p = a;          /* p now holds base address of a */

        printf("%d\n", ((int *) p)[12]); /* get 17 back */

    Usually if you have to start writing casts, it's a sign that you are doing
    something wrong, and you run the danger of violating the type system --say,
    by tricking the compiler into treating a block of bits that are supposed
    to be an int as four chars. But violating the type system like this will
    be necessary for some applications, because even the weak type system in C
    turns out to be too restrictive for writing certain kinds of "generic" code
    that work on values of arbitrary types.
Alignement
    One issue with casting pointers to and from void * is that you may violate 
    the alignmetnt restrictions for a particular kind of pointers on some 
    architectures.

    Back in the 8-bit era of the 1970s, a single load or store operation would
    access a single byte of memory, and because some data (chars) are still one
    byte wide, C pointers retain the ability to address individual bytes, But
    present day memory architectures typically have a wider data path, and the
    CPU may load or store as much as 8 bytes (64 bits) in single operations.
    This makes it natural to organize memory into 4-byte or 8-byte words even
    though addresses still refer to individual bytes. The effect of the memory
    architecture is that the address of memory words must be aligned to a 
    multiple of the word size: so with 4-byte words, the address 0x1037ef44
    (multiple of 4) could refer to a full word, but 0x1037ef45(one more than a
    multiple of 4) could only be used to refer to a byte within a word.

    What this means for a C program depends on your particular CPU and compiler.
    If you try to use something like 0x1037ef45 as an int *, one of three things
    might happen:
    	  1. The CPU might load the 4 bytes starting at this address, using 
	     two accesses to memory to piece together the full int out of
	     fragments of words. This is done on Intel architectures, but costs
	     performance.
	  2. The CPU might quietly zero out the last two bits of the address,
	     loading from 0x1037ef44 even though you asked for 0x1037ef45. This
	     happens on some other architectures, notably ARM.
	  3. The CPU might issue a run-time exception.

    All of these outcomes are bad, and the C standard does not specify what
    happens if you try to dereference a pointer value that does not satisfy
    the alignmetnt restrictions of its target type. Fortunately, unless you
    are doing very nasty things with casts, this is unlikely to come up, 
    because any pointer value you will see in a typical program is likely
    to arise in one of three ways:
    
	1. By taking the address of some variable. This pointer will be 
	   appropriately aligned, because the compiler allocates space for
	   each variable (including fields within structs) with 
	   appropriate alignmetnt.
	2. By computing an offset address using pointer arithmetic either
	   explicitly (p+n) or implicitly (p[n]). In either case, as long as
	   the base pointer correctly aligned, the computed pointer will also
	   be correctly aligned.
	3. By obtaining a pointer to an allocated block of memory using malloc
	   or a similar function. Here malloc is designed to always return 
	   blocks with the maximum possible required alignment, just to avoid
	   problems when you use the result elsewhere.
	   
    On many compilers , you can use __alignof(type) to get the alignment 
    restriction for a particular type. This was formalized in C11 (with a
    different name!).

    The other place where alignment can create issues is that if you make
    a struct with components with different alignment restrictions, you may end
    up with some empty spaces.For example, on a machine that enforces 4-byte
    alignment for ints, building a struct that contain a char and an int will
    give you something bigger than you might expect:

    	 #include <stdio.h>
	 struct ci {
	 	char c;  /* offset 0 */
		     	 /* 3 unused bytes go here */
		int i;   /* offset 4 */
	 }
	 struct ic {
	 	int i;   /* offset 0 */
		char c;  /* offset 4 */
	 }
	 int main(int argc, char *argv[]) {
	     printf("sizeof(struct ci) == %lu\n", sizeof(struct ci));
	     printf("sizeof(struct ic) == %lu\n", sizeof(struct ic));

	     return 0;
	 }
	 $ c99 -Wall -o structPacking structPacking.c
	 $ ./structPacking
	 sizeof(struct ci) == 8
	 sizeof(struct ic) == 8

    In both cases, the compiler packs in an extra 3 bytes to make the size of
    the struct a multiple of the worst alignment of any of its components.
    If it didn't do this, you would have trouble as soon as you tried to make
    an array of these things.

Run-time storage allocation using malloc
    C does not generally permit arrays to be declared with variable sizes
    C also doesn't let local variables outlive the function they are declared
    in. Both features can be awkward if you want to build data structures at
    run time that have unpredicatable (perhaps even changing) sizes and that
    are intended to persist longer than the function that create them. To build
    such structures, the standard C library provides the malloc routine, which
    asks the operating system for a block of space of a given size (in bytes).
    With a bit of pushing and shoving, this can be used to obtain a block of 
    space that for all practical purposes acts just like an array.

    To use malloc, you must include stdlib.h at the top of your program. The 
    declaration for malloc is 

    		void *malloc(size_t);

    where size_t is an integer type (often unsigned long). Calling malloc with
    an argument of n allocates and returns a pointer to the start of a block of
    n bytes if possible. If the system can't give you the space you asked for
    (maybe you asked for more space than it has), malloc returns a null pointer.
    It is good practice to test the return value of malloc whenever you call it.

    Because the return type of malloc is void *, it's return value can be assigned
    to any variable with a pointer type. Computing the size of the block you need
    is your responsibility -- and you will be punished for any mistakes with 
    difficult-to-diagnose buffer overrun errors --but this task is made slightly
    easier by the built-in sizeof operator that allows you to compute the size
    in bytes of any particular data types.

    When you are donw with a malloc'd region, you should return the space to
    the system using the free routine, also defined in stdlib.h. If you don't 
    do this, your program will quickly run out of space. The free routine takes
    a void * as its argument and returns nothing. It is good practice to write 
    a matching destructor that de-allocates an object for each constructor 
    (like makeIntArray) that makes one.

    void destroyIntArray(int *a) {
        free(a);
    }
    
    It is a serious error to do anything at all with a block after it has been
    freed. This is not necessarily because free modifies the contents of the 
    block(although it might), but because when you free a block you are 
    granting  the storage allocator permission to hand the same block out in 
    response to a future call to malloc, and you don't want to step on whatever
    other part of your program is now trying to use that space.

    It is also possible to grow or shrink a previously allocated block. This is
    done using the realloc function, which is declared as

    void *realloc(void *oldBlock, size_t newSize);

    The realloc function return a pointer to the resized block. It may or may 
    not allocate a new block. If there is room, it may leave the old block in 
    place and return its argument. But it may allocate a new block and copy 
    the contents of the old block, so you should assume that the old pointer 
    has been freed.

Function pointers
    A function pointer, internally, is just the numerical address for the code
	a function. when a function name is used by itself without parentheses, the
	value is a pointer to the function, just as the name of an array by itself
	is a pointer to its zeroth element. Function pointers can be stored in 
	variables, structs, unions, and arrays and passed to and from function just
	like any other pointer type. They can also be called: a variable of type
	function pointer can be used in place of a function name.

	Function pointers are not used as much in C as in functional languages, but
	there are many common uses even in C code.
Function pointer declarations
    A Function pointer declaration looks like a Function declaration, except 
	that the Function name is wrapped in parentheses and preceded by an asterisk.
	For example:

	/* a Function taking two int arguments and returning an int */
	int Function (int x, int y);

	/* a pointer to such a function */
	int (* pointer)(int x, int y);

	As with function declarations, the names of the arguments can be omitted.

Callbacks 
    A callback is when we pass a function pointer into a function so that the
	function can call our function when some event happens or it needs to 
	compute something.

	A classic example is the comparison argument to qsort, from the standard
	library:
	
	/* defined in stdlib.h */
	void
	qsort(
		void *base,
		size_t n,
		size_t size,
		int (*cmp)(const void *key1, const void *key2)
	);

	This is a generic sorting routine that will sort any array in place. It 
	needs to know (a) the base address of the array; (b) how many elements
	there are; (c) how big each element is; and (d) how to compute two 
	elements. The only tricky part is supplying the comparison, which could
	involve arbitrarily-complex code. So we supply this code as a function 
	with an interface similar to strcmp.

	static int
	compare_ints(void *key1, void *key2)
	{
		return *((int *) key1) - *((int *) key2);
	}

	int
	sort_int_array(int *a, int n)
	{
		qsort(a, n, sizeof(*a), compare_ints);
	}

	Other examples might include things like registering an error handler for a
	library, instead of just having it call abort() or something equally 
	catastrophic, or providing a cleanup function for freeing data passed into a
	data structure.

Dispatch tables
    Alternatives to gigantic if/else if or switch  statements. The idea is to 
	build an array of function pointers(or, more generally, some sort of 
	dictionary data structure), and use the value we might otherwise be feeding
	to switch as an index into this array. Here is a simple example, which 
	echoes most of the characters in its input intact, except for echoing every
	lowercase vowel twice.

Strings
    There are two standard ways to represent strings
	* As a delimited string
	  Where the end of a string is marked by a special character. The advantages
	  of this method are that only one extra byte is needed to indicate the
	  length of an arbitrary long string, that strings can be manipulated by a
	  simple pinter operations, and in some cases that common string operations
	  that involve processing the entire string can be performed very quickly.
	  The disadvantage is that the delimiter can't appear inside any string, 
	  which limits what kind of data you can store in a string.
	* As a Counted string
	  Where the string data is prefixed or supplemented with an explicit count
	  of the number of characters in the string. The advantage of this
	  representation is that a string can hold arbitrary data (including 
	  delimiter characters) and that one can quickly jump to the end of the 
	  string without having to scan its entire length. The disadvantage is
	  that maintaining a separate count typically requires more space than
	  adding a one-byte delimiter (unless you limit your string length to 255
	  characters - Because count upto 255 can be managed in 1 byte) and that 
	  more care needs to be taken to make sure that the count is correct.

C strings
    Because delimited strings are simpler and take less space, C went for 
	delimited strings. A string is a sequence of characters terminated by a null
	character '\0'.
	Note that the null character is not the same as null pointer, although both
	appear to have the value 0 when used in integer contexts. A string is 
	represented by a variable of type char *, which points to the zeroth
	character of the string.
	The programmer is responsible for allocating and managing space to store 
	strings, except for explicit string constants, which are stored in a 
	special non-writable string space by the compiler.
	
	If you want to use counted strings instead, you can build your own using a
	struct. Most scripting languages written in C (e.g. Perl, Python, PHP, etc.)
	use this approach internally. (Tcl is an exception , which is one of many 
	good reasons not to use Tcl).

String Constants
    A string constant in C is represented by a sequence of characters within 
	double quotes. Standard c character escape sequences like \n(newline), \r
	(carriage return ), \a (bell) , \0x17 (character with hexadecimal code 0x17)
	, \\ (backslash), and \"(double quote) can all be used inside string 
	constants. The value of a string constant has type const char *, and can be
	assigned to variables and passed as function arguments or return-values of
	this type.

	Two string constants seperated only by whitespaces will be concatenated by
	the compiler as a single constant: "foo" "bar" is the same as "foobar".
	This feature is not much used in normal code, but shows up Sometimes in 
	macros.

String buffers
    The problem with string constant is that you can't modify them( immutable
	sort of in object oriented world). If you want to build strings on the fly,
	you will need to allocate space for them. The traditional approach is to 
	use a buffer, an array of chars.
	
	char hi[3] = { 'h', 'i', '\0' };
	puts(hi) --> 'hi'

	Note that the buffer needs to have size at least 3 in order to hold all 
	three characters. A common error in programming with C strings is to forget
	to leave space for the null at the end (or to forget to add the null, which
	can have comical results depending on what you are using your surprisingly
	long string for).

String Buffers and the perils of gets
    Fixed-size buffers are a common source of errors in older C programs, 
	particularly ones written with the library routine gets. The problem is that
	if you do something like
	   
	   strcpy(smallBuffer, bigString);

	the strcpy function will happily keep copying characters across memory long
	after it has passed the end of smallBuffer. While you can avoid this to a
	certain extent when you control where bigString is coming from, the 
	situation becomes particularly fraught if the string you are trying to store
	comes from the input, where it might be supplied by anybody, including 
	somebody who is trying to execute a buffer overrun attack to seize control
	of your program.
	If you do need to read a string from the input, you should allocate the 
	receiving buffer using malloc and expand it using realloc as needed.

Operations on Strings
    Unlike many programming languages, C provides only a rudimentary string
	processing library. The reason is that many common string-processing tasks
	in C can be done very quickly by hand.

	For example, suppose we want to copy a string from one buffer to another.
	The library function strcpy declared in string.h will do this for us (and is
	usually the right thing to use), but if it didn't exist we could write
	something very close to it using a famous C idiom.
	
	void
	strcpy2(char *dest, const char *src) {
		while (*dest++ = *src++);
	}
	
	The externally visible difference between strcpy2 and the original strcpy is
	that strcpy returns a char * equal to its first argument. It is also likely
	that any implementation of strcpy found in a recent C library takes 
	advantage of the width of the memory data path to copy more than one 
	character at a time.

	Because C pointers act exactly like array names, you can also write strcpy2
	using explicit array indices. the result is longer but may be more readable
	if you aren't a C fanatic.

	char * strcpy2a(char *dest, const char *src) {
		 int i;
		 for (i = 0; str[i] != '\0'; i++) [
		 	 dest[i] = src[i];
		 }
		 
		 dest[i] = '\0';
		 return dest;
	}
	
	An advantage of using a seperate index in strcpy2a is that we don't trash 
	dest, so we can return it just like strcpy does. (In fairness, strcpy2 could
	have saved a copy of the original location of dest and done the same thing.)

strcpy string copy caveat
    Note that nothing in strcpy2 , strcpy2a, or the orginal strcpy will save you
	if dest(destination pointer) points to a region of memory that isn't big 
	enough to hold the string at src (source pointer), or if somebody forgot to
	tack a null on the end of src (in which case strcpy will just keep going 
	until if finds a null character somewhere). As elsewhere, it's your job as
	a programmer to make sure there is enough room. Since the compiler has no
	idea what dest points to, this means that you have to remember how much room
	is available there yourself.

strncpy
    If you are worried about overrunning dest, you could use strncpy instead.
	The strncpy function takes a third argument that gives the maximum number of
	characters to copy; however, if src doesn't contain a null character in this
	range, the resulting string in dest won't either. Usually the only practical
	practical application to strncpy is to extract the file k characters of a
	string, as in stringCopy.c under Yale/examples/strings/

strcat
    A similar operation to strcpy is strcat. The difference is that strcat 
	concatenates src on to the end of dest; so that if dest previous pointed to
	"abc" and src to "def", dest will now point to "abcdef". Like strcpy, strcat
	returns its first argument. A non-return-value version of strcat :
	
	void
	strcat2(char *dest, const char *src) {
		while (*dest) dest++; /* going to last of dest */
		while (*dest++ = *src++); /* now incrementing dest with src */
	}

strncat
    strncat has the same relationship to strcat that strncpy has to strcpy.
	As with strcpy, the actual implementation of strcat may be much more subtle,
	and is likely to be faster than rolling your own.

Finding the length of a string
    Because the length of a string is of fundamental importance in C (e.g. when
	deciding if you can safely copy it somewhere else), the standard C library
	provides a function strlen that counts the number of non-null characters in 
	a string (until the first null '\0' is encountered). Note that if you are
	allocating space for a copy of a string, you will need to add one to the 
	value returned by strlen to account for null.

	Here's a possible implementation:
	
	int strlen(const char *s) {
		int i;
		for(i = 0; *s; i++, s++) continue;
		return i;
	}
	
	Note the use of the comma operator in the increment step. The comma operator
	applied to two expression evaluates both of them and discards the value of 
	the first; it is usually used only in for loops where you want to initialize
	or advance more than one variable at once.

The strlen tarpit
    A common mistake is to put a call to strlen in the header of a loop; for eg:
	
	char *
	copyEvenCharactersBadVersion(char *dest, const char *src) {
  	    int i;
		int j;
		
		/* BAD: Calls strlen on every pass through the loop */
		for(i = 0, j = 0; i < strlen(src); i += 2, j++) {
			  dest[j] = src[i];
		}
		
		dest[j] = '\0';
		
		return dest;
	}

Comparing Strings
    If you  want to test if strings s1 and s2 contain the same character, writing
	s1 == s2 won't work, since this tests instead whether s1 and s2 won't work,
	since this tests instead whether s1 and s2 points to the same address. 
	Instead, you should use strcmp, declared in string.h. The strcmp function
	walks along both of its arguments until it either hits a null on both and
	returns 0, or hits two different characters,  and returns a positive integer
	if the first string's character is bigger and a negative integer if the 
	second string's character is bigger ( a typical implementation will just 
	subtract the two characters). A straightforward implementation might look
	like this:
	
	int strcmp(const char *s1, const char *s2) {
		while(*s1 && *s2 && (*s1 == *s2)) {
			s1++;
			s2++;
		}
		return *s1 - *s2;
	}
	
Formatted output to Strings
    You can write formatted output to a string buffer with sprintf just like you
	can write it to stdout with printf or to a file with fprintf. Make sure when
	you do so that there is enough room in the buffer you are writing to, or the
	usual bad things will happen.

Dynamic allocation of Strings
    When allocating space for a copy of a string s using malloc, the required 
	space is strlen(s)+1. Don't forget the +1, or bad things may happen.

	Because allocating space for a copy of a string is such a common operation, 
	many C libraries provide a strdup function that does exactly this.

Command-line arguments
    Now that we know about strings, we can finally do something with argc and
	argv.

	Recall that argv in main is declared as char**; this means that it is a 
	pointer to a pointer to a char , or in this case the base address of an 
	array of pointers to char, where each such pointer references a string.These
	strings correspond to the Command-line arguments of your program, with the 
	program name itself appearing in argv[0]

	The count argv counts all arguments including argv[0]; it is 1 if your
	is called with no arguments and larger otherwise.

	Like strings, C terminates argv with a null; the value of argv[argc] is 
	always 0 (a null pointer to char). In principle this allows you to recover
	argc if you lose it.

Structured data types
    C has two kinds of structured data types:  structs and unions. A struct 
	holds multiple values in consecutive memory locations, called fields, and
	implements what in type theory is called a product type: the set of possible
	values is the Cartesian product of the sets of possible values for its  
	fields. In contrast, a union has multiple fields but they are all stored in 
	the same location: effectively, this means that the only one field at a time
	can hold a value, making a union a sum type whose set of possible values is
	the union of the sets of possible values for each of its fields. Unlike what
	happens in more sensible programming languages, unions are not tagged:
	unless you keep track of this somewhere else, you can't tell which field in
	a union is being used, and you can store a value of one type in a union and
	try to read it back as a different type, and C won't complain.

Structs
    A struct is a way to define a type that consists of one or more other types	
	pasted together. Here's a typical struct definition:

	struct string {
		   int length;
		   char *data;
	};

	The defines a new type string that can be used anywhere you would use a 
	simple type like int or float. When you declare a variable with type struct
	string , the Compiler allocates enough space to hold both an int and a char*
	(8 bytes on a typical 32-bit machine). You can get at the individual 
	components using the . operator.

Operations on Structs
    Variables of type struct can be assigned to, passed into functions, returned
	from functions, and tested for equality, just like any other type. Each such
	operation is applied componentwise; for example, s1 = s2; is equivalent to 
	s1.length = s2.length; s1.data = s2.data; and s1 == s2 is equivalent to
	s1.length == s2.length && s1.data == s2.data.

	These operations are not used as often as you might think: typically, instead
	copying around entire structues, C programs pass around pointers, as is done
	with arrays Pointers to structs are common enough in C that a special syntax
	is provided for dereferencing them. Suppose we have:
	
		struct string s;          /* a struct */
		struct string *sp;        /* a pointer to a struct */

		a.length = 4;
		s.data = "another overly long string";

		sp = &s;         /*sp now points to s  */

		We can then refer to elements of the struct string that sp points to
		(i.e. s) in either of two ways:
			  puts((*sp).data);
			  puts(sp->data);

    The second is more common, since it involves fewer parentheses. It is an 
	error to write *sp.data in this case; since . binds tighter than *, the 
	compiler will attempt to evaluate sp.data first and generate an error, since
	sp doesn't have a data field.

	Pointers to struct are commonly used in defining abstract data type, since 
	it is possible to declare that a function returns e.g. a struct string * 
	without specifying the components of a struct string. (All pointers to 
	structs in C have the same size and structure, so the compiler doesn't need
	to know the components to pass around the address.) Hiding the components 
	discourages code that shouldn't look at them from doing so, and can be used,
	for example, to enforce consistency between fields.
	have a look at Yale/examples/myString/myString.h for further clarification.

	In practice, we would probably go even further and replace all the struct
	string * types with a new name declared with typedef.

Operations on structs
    What you can do to structs in pretty limited: you can look up or set 
	individual components in a struct, you can pass structs to functions or as
	return values from functions (which makes a copy of the original struct),
	and you can assign the contents of one struct to another using s1 = s2 
	(which is equivalent to copying each component seperately (deep copy))

	One thing that you can't do is test two structs for equality using ==; this
	is Because structs may contain extra space holding junk data. If you want to
	test for equality, you will need to do it component by component.

Layout in memory
    The C99 standard guarantees that the components of a struct are stored in 
	memory in the same order that they are defined in: that is, later components
	are placed at higher address. This allows sneaky tricks like truncating a
	structure if you don't use all of its components. Because of alignment
	restrictions, the Compiler may add padding between components to put each 
	component on its preffered alignment boundary.

offset,stddef.h
    You can find the position of a component within a struct using the offsetof
	macro , which is defined in stddef.h. This returns the number of bytes from
	the base of the struct that the component starts at, and can be used to do
	various terrifying non-semantic things with pointers.

Bitfields
    It is possible to specify the exact number of bits taken up by a member of a
	struct of integer type.This is seldom useful, but may in principle let you 
	pack more information in less space. Bit fields are sometimes used to unpack
	data from an external source that uses this trick, but this is dangerous, 
	because there is no guarantee that the compiler will order the bit fields in
	your struct in any particular order (at the very least , you will need to worry
	about the endianness. 

	Example:
	struct color {
		   unsigned int red    : 2;
		   unsigned int green: 2;
		   unsigned int blue  : 2;
		   unsigned int alpha: 2;
	};

	This defines a struct that (probably) occupies only one byte, and supplies 
	four 2-bit fields, each of which can hold values in the range 0-3.

Unions
    A Union is just like a struct, except that instead of allocating space to store
	all the components, the compiler only allocates space to store the largest one,
	and makes all the components refer to the same address. This can be used to
	save space if you know that only one of several components will be 
	meaningful for a particular object. An example might be a type representing
	an object in a LISP-like language like Scheme: 

	   struct lispObject {
	   		  int type;               /* type code */
			  union {
			  		int           intVal;
					double   floatVal;
					char *     stringVal;
					struct     {
							   struct lispObject *car;
							   struct lispObject *cdr;
					} consVal;
			  } u;
		};

	Now if you wanted to make a struct lispObject that held an integer value,
	you might write
		
		lispObject o;

		o.type = TYPE_INT;
		o.u.intVal = 27;

	Here TYPE_INT has presumably been defined somewhere. Note that nothing then
	prevents you from writing
			 
			 x = 2.7 * o.u.floatVal;         /* BAD */

	The effects  of this will be strange, Since it's likely that the bit pattern representing
	27 as an int represents something  as a double. Avoiding such mistakes is your 
	responsibility, which is why most uses of union occur inside larger structs that
	contain enough information to figure out which variant of the union applies.
    
Enums
    C provides the enum construction for the special case where you want to have
	a sequence of named constants of type int, but you don't care what their actual 
	values are , as in
		   
		   enum color {	RED, BLUE, GREEN, MAUVE, TURQUOISE };

    This will assign the value 0 to RED, 1 to BLUE, and so on These values are 
	effectively of type int, although you can declare variables , arguments, and 
	return values as type enum color to indicate their intended interpretations.

	Despite declaring a variable enum color c (say), the compiler will still allow
	c to hold arbitrary values of type int.
	Have a look at the Yale/examples/definations/enumsAreInts.c
	
Specifying particular values
    It is also possible to specify particular values for particular enumerated 
	constants, as in
	
	enum color { RED = 37, BLUE = 12, GREEN = 66, MAUVE = 5, TURQUOISE};

    Anything that doesn't get a value starts with one plust the previous value;
	so the above definition would set TURQUOISE to 6. This may result in two
	names mapping to the same value.

What most people do
	In practice, enums are seldom used , and you will more commonly see a stack
	of #defines:
	#define RED          (0)
	#define BLUE        (1)
	#define GREEN     (2)
	#define MAUVE    (3)
	#define TURQUOISE (4)
	The reason for this is partly historical -enum arrived late in the evolution
	of C - but partly practical: a table of #defines makes it much easier to figure
	out which color is represented by 3, without having to count through a list.
	But if you never plan to use the numberical values, enum may be a better 
	choice, because it guarantees that all the  values will be distinct.

Using enum with union 
    a natural way to use an enum is to tag a union with the type being used. For
	example, a Lisp-like language might implement the following multi-purpose
	data type:

	enum TypeCode { TYPE_INT, TYPE_DOUBLE, TYPE_STRING };

	struct LispValue {
		   enum TypeCode typeCode;
		   union {
		   		 int i;
				 double d;
				 char *s;
			} value;
		};
    Here we don't care what the numberic values of TYPE_INT, TYPE_DOUBLE, and
	TYPE_STRING are, as long as we can apply switch to typeCode to figure out what
	to do with one of these things.

Type aliases using typedef
	 Suppose that you want to represent character strings as
	 struct string {
	     int length;
		 char *data;
	};
	